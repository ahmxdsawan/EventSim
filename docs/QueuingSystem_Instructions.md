# Queuing System Simulations
To create an Queueing System simulation define the following:

### System
First, subtype your Sim with respect to the `QueueingSystem` type

    struct MyQSystem <: QueueingSystem
        parm1::P1Type
        etc.
    end

### Events
Then create event singletons: one per event type

    struct A  <: Event end
    struct D1 <: Event end
    struct D2 <: Event end
    struct D3 <: Event end
    struct D4 <: Event end
    etc.  ...

### Initial Event
Next, define the initial event function `initialevent()`
- this function gets run by the system to set up the events list
    - the events list is automatically generated by the system; you do not have to provide it
- the `initialevent()` function provides the event to be processed at time 0
    - hence you do not have to provide a time

    initialevent(sim::MyQSystem) = A

### End Time
Next, define the end time function `endtime()`
- this function gets run by the system to set up the events list
- the events list will be produced, with the EndEvent automatically scheduled at the supplied end time

Example:

    endtime(sim::MyQSystem) = 100

### State Definition
You setup the state in the same way you did with previous state simulators by defining
- `MyState <: State`
- `startstate()`
- the state verbose functions  
(*see the verbose mode documentation*)

### State Updates
Next, create a series of `state!()` update functions, one per event   
- these also update the state variable
    - the state update has been split into state! and stats! for functional decomposition and readablility
    - the stats! function is run before the state! function

Examples:

    function state!(e::A, sim::MyEventSim, state, eventList)
        state update function for event A
        you can also post events on the eventList
            - e.g. posting a D3 event 85.32 clock ticks from now
              post!(eventList, D3, 85.32)
    end 

    function state!(e::D1, sim::MyEventSim, state, eventList)
        state update function for event D1 
        etc.
    end

    etc.

### Stats Updates
Next, create a series of `stats!()` update functions, one per event   
- (these replace the single `update!()` function from `StateSim`)

Examples:

    function stats!(e::A, sim::MyEventSim, state, eventList)
        - update stats variables inside the state for event A
        - can retrive time information from the eventList such as 
            Δprev(eventList)
                - the time diff btw the last event and now
            Δpost(eventList) 
                - the time diff btw the posting of the current event and now
    end 

    function stats!(e::D1, sim::MyEventSim, state, eventList)
        - update stats variables inside the state for event D1
        - etc. 
    end

    etc.

In almost all cases you will want a stats!() function for the EndEvent
- this will be used to update timing statistics such as wait times W etc. to the end of the run

state!() updates for EndEvent is not as common, 
- however, sometimes you will want to define it to clean up your state
- e.g., closing up the shop

### Changes from previous simulators
You do **not** have to: 
- define a `maxitr` 
    - as the list itself implies the number of iterations (the length of the list)
- define `update!()`
    - this is already covered by the `state!()` method for each event
- define the `EventList`
    - this gets automatically produced by the system using `startevent()` and `endtime()`

##
## Summary
- subtype your Sim: 
    - MyQSystem <: QueueingSystem
- create event singletons: one per event type
    - `struct A  <: Event end`  
    `struct D1 <: Event end`  
    `struct D2 <: Event end`  
    etc.`
- define the initial event function `initialevent()`
    - set to the event that starts the simulation at time = 0
    - `initialevent(sim::MyQSystem) = A`
- define the end time function `endtime()`
    - this function is run when the system sets up the events list to find the time to schedule the EndEvent
    - `endtime(sim::MyQSystem) = 100`
- create a series of `state!()` update functions  
    - one per event  
- create a series of `stats!()` update functions
    - one per event
    - remember to add one for `EndEvent`  
- Finally, setup the rest of simulator as you would a regular state simulator by defining
    - `MyState <: State`
    - `startstate()`
    - the verbose functions <small>(*see the verbose mode documentation*) </small>
